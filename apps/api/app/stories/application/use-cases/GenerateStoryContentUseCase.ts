import { inject } from '@adonisjs/core'
import logger from '@adonisjs/core/services/logger'
import { IStoryRepository } from '#stories/domain/repositories/StoryRepository'
import { IStoryGenerationService } from '#stories/domain/services/IStoryGeneration'
import { ChapterFactory } from '#stories/domain/factories/ChapterFactory'
import { ImageUrl } from '#stories/domain/value-objects/media/ImageUrl.vo'
import { Slug } from '#stories/domain/value-objects/metadata/Slug.vo'
import { IUserRepository } from '#users/domain/repositories/UserRepository'
import queue from '@rlanz/bull-queue/services/main'
import SendStoryGeneratedSuccessEmailJob from '#jobs/story/send_story_generated_success_email_job'
import SendStoryGenerationFailedEmailJob from '#jobs/story/send_story_generation_failed_email_job'
import type { Story } from '#stories/domain/entities/story.entity'

export interface GenerateStoryContentPayload {
  storyId: string
  synopsis: string
  theme: string
  protagonist: string
  childAge: number
  numberOfChapters: number
  language: string
  tone: string
  species: string
}

@inject()
export class GenerateStoryContentUseCase {
  constructor(
    private readonly storyRepository: IStoryRepository,
    private readonly storyGenerationService: IStoryGenerationService,
    private readonly userRepository: IUserRepository
  ) {}

  async execute(payload: GenerateStoryContentPayload) {
    logger.info(`ü§ñ Generating story content for: ${payload.storyId}`)

    // 1. R√©cup√©rer la story
    const story = await this.storyRepository.findById(payload.storyId)
    if (!story) throw new Error('Story not found')

    try {
      // 2. G√©n√©rer le contenu avec AI
      const storyGenerated = await this.storyGenerationService.generateStory({
        title: story.title,
        synopsis: payload.synopsis,
        theme: payload.theme,
        protagonist: payload.protagonist,
        childAge: payload.childAge,
        numberOfChapters: payload.numberOfChapters,
        language: payload.language,
        tone: payload.tone,
        species: payload.species,
        isPublic: story.isPublic(),
        ownerId: story.ownerId.getValue(),
        status: story.generationStatus,
      })

      // 3. Cr√©er les entit√©s Chapter
      const chapters = storyGenerated.chapters.map((chapterData) => {
        const position = chapterData.id.getValue()

        if (chapterData.image) {
          return ChapterFactory.createWithImage({
            position,
            title: chapterData.title,
            content: chapterData.content,
            imageUrl: chapterData.image.imageUrl.getValue(),
          })
        }

        return ChapterFactory.createWithoutImage({
          position,
          title: chapterData.title,
          content: chapterData.content,
        })
      })

      // 4. Mettre √† jour la story avec le contenu g√©n√©r√©
      // IMPORTANT: Utiliser le slug d√©j√† g√©n√©r√© et v√©rifi√© comme unique par le service de g√©n√©ration
      const updatedStory = story.completeGeneration(
        chapters,
        ImageUrl.create(storyGenerated.coverImageUrl),
        storyGenerated.conclusion,
        storyGenerated.title,
        Slug.create(storyGenerated.slug) // Use the unique slug generated by the story generation service
      )

      await this.storyRepository.save(updatedStory)

      // Dispatch success email (non-blocking)
      this.dispatchSuccessEmail(updatedStory).catch((error) => {
        logger.error('‚ö†Ô∏è Failed to dispatch success email job:', error.message)
      })

      logger.info(`‚úÖ Story generation completed: ${payload.storyId}`)
      logger.info(`üìñ Generated title: "${storyGenerated.title}"`)
      logger.info(`üîó Generated slug: "${storyGenerated.slug}"`)

      return updatedStory
    } catch (error: any) {
      logger.error(`‚ùå Story generation failed: ${error.message}`)

      // Marquer comme √©chou√© seulement si le status est processing
      if (story.generationStatus.isProcessing()) {
        story.failGeneration(error.message)
        await this.storyRepository.save(story)

        // Dispatch failure email (non-blocking)
        this.dispatchFailureEmail(story, error.message).catch((emailError) => {
          logger.error('‚ö†Ô∏è Failed to dispatch failure email job:', emailError.message)
        })
      } else {
        logger.error(
          `‚ö†Ô∏è Cannot mark story as failed: status is ${story.generationStatus.getValue()}, expected processing`
        )
      }

      throw error
    }
  }

  /**
   * Dispatch success email notification job
   */
  private async dispatchSuccessEmail(story: Story): Promise<void> {
    try {
      // Retrieve user information
      const user = await this.userRepository.findById(story.ownerId.getValue())

      if (!user) {
        logger.warn(`‚ö†Ô∏è User not found: ${story.ownerId.getValue()}`)
        return
      }

      // Dispatch email job
      await queue.dispatch(SendStoryGeneratedSuccessEmailJob, {
        recipientEmail: user.email.getValue(),
        recipientName: user.getFullName(),
        storyTitle: story.title,
        storySlug: story.slug.getValue(),
      })

      logger.info(`üìß Success email dispatched for ${user.email.getValue()}`)
    } catch (error: any) {
      logger.error('‚ùå Error dispatching success email:', error.message)
      // Don't throw - continue execution
    }
  }

  /**
   * Dispatch failure email notification job
   */
  private async dispatchFailureEmail(story: Story, errorMessage: string): Promise<void> {
    try {
      // Retrieve user information
      const user = await this.userRepository.findById(story.ownerId.getValue())

      if (!user) {
        logger.warn(`‚ö†Ô∏è User not found: ${story.ownerId.getValue()}`)
        return
      }

      // Simplify error message for user
      const userFriendlyError = this.simplifyErrorMessage(errorMessage)

      // Dispatch email job
      await queue.dispatch(SendStoryGenerationFailedEmailJob, {
        recipientEmail: user.email.getValue(),
        recipientName: user.getFullName(),
        storyId: story.id.getValue(),
        errorMessage: userFriendlyError,
      })

      logger.info(`üìß Failure email dispatched for ${user.email.getValue()}`)
    } catch (error: any) {
      logger.error('‚ùå Error dispatching failure email:', error.message)
      // Don't throw - continue execution
    }
  }

  /**
   * Simplify technical error messages for end users
   */
  private simplifyErrorMessage(technicalError: string): string {
    if (technicalError.includes('quota') || technicalError.includes('rate limit')) {
      return 'Limite de requ√™tes atteinte. Veuillez r√©essayer dans quelques instants.'
    }

    if (technicalError.includes('timeout') || technicalError.includes('timed out')) {
      return 'Le serveur a mis trop de temps √† r√©pondre. Veuillez r√©essayer.'
    }

    if (technicalError.includes('API') || technicalError.includes('OpenAI')) {
      return 'Service de g√©n√©ration temporairement indisponible. Veuillez r√©essayer.'
    }

    return 'Une erreur technique est survenue. Notre √©quipe a √©t√© notifi√©e.'
  }
}
