import { inject } from '@adonisjs/core'
import logger from '@adonisjs/core/services/logger'
import env from '#start/env'
import { IStoryRepository } from '#stories/domain/repositories/story_repository'
import { IStoryGenerationService } from '#stories/domain/services/i_story_generation'
import { ITranslationService } from '#stories/domain/services/i_translation_service'
import { ChapterFactory } from '#stories/domain/factories/chapter_factory'
import { ImageUrl } from '#stories/domain/value-objects/media/image_url.vo'
import { Slug } from '#stories/domain/value-objects/metadata/slug.vo'
import { IUserRepository } from '#users/domain/repositories/user_repository'
import queue from '@rlanz/bull-queue/services/main'
import SendStoryGeneratedSuccessEmailJob from '#jobs/story/send_story_generated_success_email_job'
import SendStoryGenerationFailedEmailJob from '#jobs/story/send_story_generation_failed_email_job'
import type { Story } from '#stories/domain/entities/story.entity'
import type { StoryGenerated } from '#stories/domain/services/types/story_generated'

export interface GenerateStoryContentPayload {
  storyId: string
  synopsis: string
  theme: string
  protagonist: string
  childAge: number
  numberOfChapters: number
  language: string
  languageCode: string
  tone: string
  species: string
  appearancePreset?: string
  illustrationStyle?: string
}

@inject()
export class GenerateStoryContentUseCase {
  private readonly SOURCE_LANGUAGE = env.get('STORY_SOURCE_LANGUAGE', 'French')
  private readonly SOURCE_LANGUAGE_CODE = env.get('STORY_SOURCE_LANGUAGE_CODE', 'FR')

  constructor(
    private readonly storyRepository: IStoryRepository,
    private readonly storyGenerationService: IStoryGenerationService,
    private readonly translationService: ITranslationService,
    private readonly userRepository: IUserRepository
  ) {}

  async execute(payload: GenerateStoryContentPayload) {
    logger.info(`ü§ñ Generating story content for: ${payload.storyId}`)

    // 1. R√©cup√©rer la story
    const story = await this.storyRepository.findById(payload.storyId)
    if (!story) throw new Error('Story not found')

    try {
      // 2. D√©terminer si la traduction est n√©cessaire
      const needsTranslation = this.translationService.needsTranslation(payload.languageCode)
      const generationLanguage = needsTranslation ? this.SOURCE_LANGUAGE : payload.language

      if (needsTranslation) {
        logger.info(
          `üåê Translation needed: generating in ${this.SOURCE_LANGUAGE}, will translate to ${payload.language} (${payload.languageCode})`
        )
      }

      // 3. G√©n√©rer le contenu avec AI (en fran√ßais si traduction n√©cessaire)
      let storyGenerated = await this.storyGenerationService.generateStory({
        storyId: payload.storyId,
        title: story.title,
        synopsis: payload.synopsis,
        theme: payload.theme,
        protagonist: payload.protagonist,
        childAge: payload.childAge,
        numberOfChapters: payload.numberOfChapters,
        language: generationLanguage,
        tone: payload.tone,
        species: payload.species,
        isPublic: story.isPublic(),
        ownerId: story.ownerId.getValue(),
        status: story.generationStatus,
        appearancePreset: payload.appearancePreset,
        illustrationStyle: payload.illustrationStyle,
      })

      // 4. Traduire si n√©cessaire
      if (needsTranslation) {
        logger.info(`üîÑ Translating story to ${payload.language}...`)
        storyGenerated = await this.translateStory(storyGenerated, payload.languageCode)
        logger.info(`‚úÖ Translation completed`)
      }

      // 5. Cr√©er les entit√©s Chapter
      const chapters = storyGenerated.chapters.map((chapterData) => {
        const position = chapterData.id.getValue()

        if (chapterData.image) {
          return ChapterFactory.createWithImage({
            position,
            title: chapterData.title,
            content: chapterData.content,
            imageUrl: chapterData.image.imageUrl.getValue(),
          })
        }

        return ChapterFactory.createWithoutImage({
          position,
          title: chapterData.title,
          content: chapterData.content,
        })
      })

      // 6. Mettre √† jour la story avec le contenu g√©n√©r√©
      // IMPORTANT: Utiliser le slug d√©j√† g√©n√©r√© et v√©rifi√© comme unique par le service de g√©n√©ration
      const updatedStory = story.completeGeneration(
        chapters,
        ImageUrl.create(storyGenerated.coverImageUrl),
        storyGenerated.conclusion,
        storyGenerated.title,
        Slug.create(storyGenerated.slug), // Use the unique slug generated by the story generation service
        storyGenerated.characterVisualLock // Persist character visual lock for image consistency
      )

      await this.storyRepository.save(updatedStory)

      // Dispatch success email (non-blocking)
      this.dispatchSuccessEmail(updatedStory).catch((error) => {
        logger.error('‚ö†Ô∏è Failed to dispatch success email job:', error.message)
      })

      logger.info(`‚úÖ Story generation completed: ${payload.storyId}`)
      logger.info(`üìñ Generated title: "${storyGenerated.title}"`)
      logger.info(`üîó Generated slug: "${storyGenerated.slug}"`)

      return updatedStory
    } catch (error: any) {
      logger.error(`‚ùå Story generation failed: ${error.message}`)

      // Marquer comme √©chou√© seulement si le status est processing
      if (story.generationStatus.isProcessing()) {
        story.failGeneration(error.message)
        await this.storyRepository.save(story)

        // Dispatch failure email (non-blocking)
        this.dispatchFailureEmail(story, error.message).catch((emailError) => {
          logger.error('‚ö†Ô∏è Failed to dispatch failure email job:', emailError.message)
        })
      } else {
        logger.error(
          `‚ö†Ô∏è Cannot mark story as failed: status is ${story.generationStatus.getValue()}, expected processing`
        )
      }

      throw error
    }
  }

  /**
   * Dispatch success email notification job
   */
  private async dispatchSuccessEmail(story: Story): Promise<void> {
    try {
      // Retrieve user information
      const user = await this.userRepository.findById(story.ownerId.getValue())

      if (!user) {
        logger.warn(`‚ö†Ô∏è User not found: ${story.ownerId.getValue()}`)
        return
      }

      // Dispatch email job
      await queue.dispatch(SendStoryGeneratedSuccessEmailJob, {
        recipientEmail: user.email.getValue(),
        recipientName: user.getFullName(),
        storyTitle: story.title,
        storySlug: story.slug.getValue(),
      })

      logger.info(`üìß Success email dispatched for ${user.email.getValue()}`)
    } catch (error: any) {
      logger.error('‚ùå Error dispatching success email:', error.message)
      // Don't throw - continue execution
    }
  }

  /**
   * Dispatch failure email notification job
   */
  private async dispatchFailureEmail(story: Story, errorMessage: string): Promise<void> {
    try {
      // Retrieve user information
      const user = await this.userRepository.findById(story.ownerId.getValue())

      if (!user) {
        logger.warn(`‚ö†Ô∏è User not found: ${story.ownerId.getValue()}`)
        return
      }

      // Simplify error message for user
      const userFriendlyError = this.simplifyErrorMessage(errorMessage)

      // Dispatch email job
      await queue.dispatch(SendStoryGenerationFailedEmailJob, {
        recipientEmail: user.email.getValue(),
        recipientName: user.getFullName(),
        storyId: story.id.getValue(),
        errorMessage: userFriendlyError,
      })

      logger.info(`üìß Failure email dispatched for ${user.email.getValue()}`)
    } catch (error: any) {
      logger.error('‚ùå Error dispatching failure email:', error.message)
      // Don't throw - continue execution
    }
  }

  /**
   * Simplify technical error messages for end users
   */
  private simplifyErrorMessage(technicalError: string): string {
    if (technicalError.includes('quota') || technicalError.includes('rate limit')) {
      return 'Limite de requ√™tes atteinte. Veuillez r√©essayer dans quelques instants.'
    }

    if (technicalError.includes('timeout') || technicalError.includes('timed out')) {
      return 'Le serveur a mis trop de temps √† r√©pondre. Veuillez r√©essayer.'
    }

    if (technicalError.includes('API') || technicalError.includes('OpenAI')) {
      return 'Service de g√©n√©ration temporairement indisponible. Veuillez r√©essayer.'
    }

    return 'Une erreur technique est survenue. Notre √©quipe a √©t√© notifi√©e.'
  }

  /**
   * Translate a generated story to the target language
   */
  private async translateStory(
    story: StoryGenerated,
    targetLanguageCode: string
  ): Promise<StoryGenerated> {
    // Translate title, synopsis, and conclusion in parallel
    const [titleResult, synopsisResult, conclusionResult] = await Promise.all([
      this.translationService.translate({
        text: story.title,
        sourceLanguage: this.SOURCE_LANGUAGE_CODE,
        targetLanguage: targetLanguageCode,
      }),
      this.translationService.translate({
        text: story.synopsis,
        sourceLanguage: this.SOURCE_LANGUAGE_CODE,
        targetLanguage: targetLanguageCode,
      }),
      this.translationService.translate({
        text: story.conclusion,
        sourceLanguage: this.SOURCE_LANGUAGE_CODE,
        targetLanguage: targetLanguageCode,
      }),
    ])

    // Translate chapters in parallel
    const translatedChapters = await Promise.all(
      story.chapters.map(async (chapter) => {
        const [chapterTitleResult, contentResult] = await Promise.all([
          this.translationService.translate({
            text: chapter.title,
            sourceLanguage: this.SOURCE_LANGUAGE_CODE,
            targetLanguage: targetLanguageCode,
          }),
          this.translationService.translate({
            text: chapter.content,
            sourceLanguage: this.SOURCE_LANGUAGE_CODE,
            targetLanguage: targetLanguageCode,
          }),
        ])

        return {
          ...chapter,
          title: chapterTitleResult.translatedText,
          content: contentResult.translatedText,
        }
      })
    )

    logger.info(`üìä Translation provider used: ${titleResult.provider}`)

    return {
      ...story,
      title: titleResult.translatedText,
      synopsis: synopsisResult.translatedText,
      conclusion: conclusionResult.translatedText,
      chapters: translatedChapters as StoryGenerated['chapters'],
    }
  }
}
